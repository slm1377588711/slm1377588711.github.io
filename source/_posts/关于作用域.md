---
title: 关于作用域
date: 2017-12-06 19:12:18
categories:
	- web前端
tags:
	- javascript
---

## 第一章 作用域是什么
- （1）作用域是一套规则，用于确定在何处以及如何查找变量。
- （2）如果查找的目的是为变量进行赋值，那么就会使用LHS查询；如果查询的目的是获取变量的值，就会使用RHS查询
- （3）赋值操作会导致LHS查询。=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作

<!-- more -->

- （4）javascript引擎首先会在代码执行前对其进行编译，在这个过程中，想var a = 2这样的声明会被分解成两个独立的步骤：
- - ① 首先，var a在其作用域中声明新变量。这会在最开始的阶段，也就是在代码执行前进行
- - ② 接下来，a=2会查询（LHS）变量a并对其进行赋值
- （5）LHS和RHS查询都会在当前执行作用域中开始，如果没有找到，就会向上级作用域继续查找目标，这样每次上升一级作用域，最后抵达全局作用域，无论找到还是没找到，都将停止
- （6）不成功的RHS查找会导致ReferenceError异常，不成功的LHS查询在非严格模式下会导致自动隐式的创建一个全局变量，在严格模式下，也会抛出ReferenceError异常。


## 第二章 词法作用域
#####  2.1.
- （1）词法作用域意味着作用域是有书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对他们进行查找
- （2）javascript中有两个机制可以“欺骗”词法作用域：eval()和with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当成作用域中的变量来处理，从而创建了一个新的词法作用域（运行时）。
- （3）这两个机制的副作用是引擎无法再编译时对作用域查找进行优化，因为引擎只能谨慎的认为这样的优化是无效的，使用这其中任何一个机制都将导致代码运行变慢，不要使用他们
 

##### 2.2.动态作用域
- （1）动态作用域是this的表亲
- （2）词法作用域与动态作用域的主要区别：
- 词法作用域实在写代码或者说定义是确定的，二动态作用域是在运行时确定的（this也是）。
- 词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。
## 第三章 函数作用域和块作用域
- （1）函数是javascript中最常见的作用域单元。本质上，声明一个在函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。
- （2）函数不是唯一的作用域单元。块作用域值得是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块
- （3）从ES3开始，try/catch结构在catch分句中具有块作用域
- （4）在ES6中引入了let关键字，用来在任意代码块中声明变量
- （5）有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择何种作用域，创造可读，可维护的优良代码
- Google维护着一个名为Traceur的项目，该项目正是用来将ES6代码转换成兼容ES6之前的环境（大部分是ES5，但不是全部）。
## 第四章 作用域提升
- （1）变量和函数声明从他们在代码中出现的位置被“移动”到了最上面，这个过程叫做提升。
- （2）只有声明本身会被提升，而赋值或其他逻辑会留在原地。
- （3）每个作用域都会进行提升操作。
- （4）函数声明会被提升，但是函数表达式却不会被提升。
- （5）我们习惯将 var a = 2;看作一个声明，而实际上JavaScript引擎并不这么认为。它将var a 和a = 2当做两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务
- （6）要注意避免城府声明，特别是普通的var声明和函数声明混合在一起的时候。函数声明会优先于var声明
## 第五章 作用域和闭包
- （1）定义在函数A内部的函数a，拥有这个函数A的词法作用域，就是创建了一个闭包。
- （2）无论通过何种手段将内部函数传递到所在的词法作用域外，他都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包
- （3）let在for头部循环，不止被声明一次，每次迭代都会声明，随后的每次迭代都会使用上一个迭代结束时的值来初始化这个变量
- （4）未来的模块机制
bar.js

```
function hello(who) {
    return "Let me introduce: " + who;
}

export hello;
foo.js
// 仅从"bar"模块导入hello()
import hello from "bar";

var hungry = "hippo";

function awesome() {
    console.log(
        hello( hungry ).toUpperCase()
    );
}

export awesome;

baz.js
// 导入完整的"foo"和"bar"模块
module foo from "foo";
module bar from "bar";

console.log(
    bar.hello( "rhino" )
); // Let me introduce: rhino

foo.awesome(); // LET ME INTRODUCE: HIPPO
```

> 解析：import可以将一个模块中的一个或多个API导入到当前作用域中，并分别绑定在一个变量上（在		我们的例子里是hello）。module会将整个模块的API导入并绑定到一个变量上（在我们的例子里是foo和bar）。export会将当前模块的一个标识符（变量、函数）导出为公共API。这些操作可以在模块定义中根据需要使用任意多次。
模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样。